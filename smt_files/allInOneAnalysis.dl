/*
 *  Copyright 2018 Secure, Reliable, and Intelligent Systems Lab, ETH Zurich
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

// Type Node
.number_type Label
.number_type Var
.number_type Fact
.type VarFact = Var|Fact

//
// Inputs
//

.decl isConst (v: Var)
.input isConst
.decl hasValue(v: Var, value: number)
.input hasValue
.decl isArg (v: Var)
.input isArg
.decl assignType       (l:Label, v:Var, f:Fact) //in order to manage to have same input this is split in two and then reassigned
.input assignType
.decl assignVar		(l:Label, v1: Var, v2: Var)
.input assignVar

//together with the jump shows the flow of the program (see DSLAnalysis, method deriveFollowsPredicates)
.decl followsMustExplicit		(l1: Label, l2: Label)
.input followsMustExplicit

.decl followsMayImplicit		(l1: Label, l2: Label)
.input followsMayImplicit

//basically captures an if
.decl jump		(l1: Label, l2: Label, l3: Label)
.input jump

//if the label appears here it means it's a destination of a jump (instr instanceof JumpDest)
.decl jumpDest       (l1: Label)
.input jumpDest

//if the label appears here it means it's a destination of a jump, but it has only one incoming branch
//most commonly if it's the instruction right next to an if
//(((JumpDest) instr).getIncomingBranches().size() == 1 && instr.getPrev() == null)
.decl oneBranchJumpDest       (l1: Label)
.input oneBranchJumpDest

//Label at which the if is placed, condition on which the if is evaluated, label of the jump / goto if condition doesn't hole (else branch)
.decl goto		(l1: Label, cond: Var, l2: Label)
.input goto

.decl join		(l1: Label, l2: Label, l3: Label)
.input join
.decl mload		(l: Label, v:Var, f:VarFact)
.input mload
.decl mstore		(l: Label, v:Var, f:VarFact)
.input mstore
.decl sload		(l: Label, v:Var, f:VarFact)
.input sload
.decl sstore		(l: Label, v:Var, f:VarFact)
.input sstore
.decl sha3		(l: Label, v:Var, f:VarFact)
.input sha3
.decl call      (l: Label, outVar:Var, gas:Var, amount:Var)
.input call

//from mayImplicit
.decl taint		(l1:Label, l2:Label, v:Var)
.input taint
.decl endIf		(l1: Label, l2: Label)
.input endIf
.decl unk	(f:VarFact)
.input unk
.decl assignVarMayImplicit		(l:Label, v1: Var, v2: Var)
.input assignVarMayImplicit
.decl assignVarMayImplicitCollapsed (l:Label, v1: Var, v2: Var)
.output assignVarMayImplicitCollapsed
//collapses assignVar and assignVarMayImplicit


//
// Derived
//

.decl mustPrecedeStep	(l1: Label, l2: Label)
.decl reassignMemory	(l:Label, v:Var)
.decl reassignStorage	(l:Label, v:Var)

.decl mustAssignType        (l:Label, v:Var, f:Fact)
.decl mayAssignType      (l:Label, v:Var, f:Fact)


//
// Output from mustExplicit
//
//Shows how the memory allocation must be at a certain point
.decl mstoreMust			(l:Label, v:Var, f:VarFact)
.output mstoreMust

//Shows how the storage situation must be at a certain point
.decl sstoreMust			(l:Label, v:Var, f:VarFact)
.output mstoreMust

.decl mustDepOn				(l: Label, v:Var, f:VarFact) //it's the old reach
.output mustDepOn
.decl mustPrecede		(l1: Label, l2: Label)
.output mustPrecede

//
// Outputs from mayImplicit
//
.decl mayFollow         		(l1: Label, l2: Label)
.output mayFollow
.decl mayDepOn		            (v:Var, f:VarFact)
.output mayDepOn
.decl instrMayDepOn     (l:Label, f:VarFact)
.output instrMayDepOn

//Shows how the memory allocation may be at a certain point
.decl mstoreMay		    (l:Label, v:Var, f:VarFact)
.output mstoreMay
.decl memoryTagsMayImplicit		(l:Label, f:VarFact)
.output memoryTagsMayImplicit

//Shows how the storage situation may be at a certain point
.decl sstoreMay		(l:Label, v:Var, f:VarFact)
.output sstoreMay

//
// Rules from mustExplicit
//
mustPrecedeStep(From, To) :- followsMustExplicit(From, To), !jumpDest(To).
mustPrecedeStep(From, Mid) :- jump(From, Mid, _), oneBranchJumpDest(Mid). //captures the label after the if
mustPrecedeStep(From, To) :- jump(From, _, To). //captures the label that follows if the if condition is not true

//mustPrecede
mustPrecede(From, To) :- mustPrecedeStep(From, To).
mustPrecede(From, To) :- mustPrecede(From, Mid), mustPrecede(Mid, To).

//must dep on
mustDepOn(Lab, Var, Fact) :- assignType(Lab, Var, Fact).
mustDepOn(Lab, Var1, Fact) :- assignVar(Lab, Var1, Var2), mustDepOn(Lab, Var2, Fact).
mustDepOn(LabTo, Var, Fact) :- mustPrecede(LabFrom, LabTo), mustDepOn(LabFrom, Var, Fact).
mustDepOn(LabTo, Var, Fact) :- join(LabFrom1, LabFrom2, LabTo), mustDepOn(LabFrom1, Var, Fact), mustDepOn(LabFrom2, Var, Fact).

mstoreMust(Lab, Offset, Type) :- mstore(Lab, Offset, Var), mustDepOn(Lab, Var, Type), ! unk(Offset).
mstoreMust(LabTo, Offset, Type) :- mustPrecedeStep(LabFrom, LabTo),  mstoreMust(LabFrom, Offset, Type), ! reassignMemory(LabTo, Offset).
mstoreMust(LabTo, Offset, Type) :- join(LabFrom1, LabFrom2, LabTo),
								mstoreMust(LabFrom1, Offset, Type),
								mstoreMust(LabFrom2, Offset, Type),
								! unk(Offset).

sstoreMust(Lab, Index, Type) :- sstore(Lab, Index, Var), mustDepOn(Lab, Var, Type), ! unk(Index).
sstoreMust(LabTo, Index, Type) :- mustPrecedeStep(LabFrom, LabTo), sstoreMust(LabFrom, Index, Type), ! reassignStorage(LabTo, Index).
sstoreMust(LabTo, Index, Type) :- join(LabFrom1, LabFrom2, LabTo),
								sstoreMust(LabFrom1, Index, Type),
								sstoreMust(LabFrom2, Index, Type),
								! unk(Index).

mustAssignType(Lab, Var, Type) :- assignType(Lab, Var, Type).
mustAssignType(Lab, Var, Type) :- mload(Lab, Offset, Var), mstoreMust(Lab, Offset, Type), ! unk(Offset).

mustAssignType(Lab, Var, Type) :- sload(Lab, Index, Var), sstoreMust(Lab, Index, Type), ! unk(Index).
mustAssignType(Lab, Var, Type) :- mstoreMust(Lab, Offset, Type), sha3(Lab, Var, Offset), ! unk(Offset).

//
// Rules from mayImplicit
//
mayFollow(LabFrom, LabTo) :- followsMayImplicit(LabFrom, LabTo).
mayFollow(LabFrom, LabTo) :- followsMayImplicit(Lab, LabTo), mayFollow(LabFrom, Lab).

taint(LabStart, LabTo, Var) :- followsMayImplicit(LabFrom, LabTo), taint(LabStart, LabFrom, Var), ! endIf(LabStart, LabTo).

assignVarMayImplicitCollapsed(Lab, Var1, Var2) :- assignVar(Lab, Var1, Var2).
assignVarMayImplicitCollapsed(Lab, Var1, Var2) :- assignVarMayImplicit(Lab, Var1, Var2).

mayDepOn(Var, Fact) :- assignType(_, Var, Fact).
mayDepOn(Var1, Fact) :- assignVarMayImplicitCollapsed(_, Var1, Var2), mayDepOn(Var2, Fact).

mayDepOn(Var1, Fact) :- assignType(Lab, Var1, _), taint(_, Lab, Var2), mayDepOn(Var2, Fact).
mayDepOn(Var1, Fact) :- assignVarMayImplicitCollapsed(Lab, Var1, _), taint(_, Lab, Var2), mayDepOn(Var2, Fact).


mstoreMay(Lab, Offset, Type) :- mstore(Lab, Offset, Var), mayDepOn(Var, Type).
mstoreMay(LabTo, Offset, Type) :- followsMayImplicit(LabFrom, LabTo), mstoreMay(LabFrom, Offset, Type), ! reassignMemory(LabTo, Offset).
memoryTagsMayImplicit(Lab, Type) :- mstoreMay(Lab, _, Type).

sstoreMay(Lab, Index, Type) :- sstore(Lab, Index, Var), mayDepOn(Var, Type).
sstoreMay(LabTo, Index, Type) :- followsMayImplicit(LabFrom, LabTo), sstoreMay(LabFrom, Index, Type), ! reassignStorage(LabTo, Index).

mayAssignType(Lab, Var, Type) :- assignType(Lab, Var, Type).
mayAssignType(Lab, Var, Type) :- mload(Lab, Offset, Var), mstoreMay(Lab, Offset, Type), ! unk(Offset).
mayAssignType(Lab, Var, Type) :- mload(Lab, Offset, Var), mstoreMay(Lab, _, Type), unk(Offset).

mayAssignType(Lab, Var, Type) :- sload(Lab, Index, Var), sstoreMay(Lab, Index, Type), ! unk(Index).
mayAssignType(Lab, Var, Type) :- sload(Lab, Index, Var), sstoreMay(Lab, _, Type), unk(Index).
mayAssignType(Lab, Var, Type) :- mstoreMay(Lab, Offset, Type), sha3(Lab, Var, Offset).


reassignStorage(Lab, Index) :- sstore(Lab, Index, _), !unk(Index).
reassignMemory(Lab, Offset) :- mstore(Lab, Offset, _), !unk(Offset).

//the same for mayImplicit and mustExplicit
reassignStorage(Lab, Index) :- sstore(Lab, Index, _), !unk(Index).
reassignMemory(Lab, Offset) :- mstore(Lab, Offset, _), !unk(Offset).
